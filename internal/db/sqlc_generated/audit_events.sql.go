// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audit_events.sql

package db

import (
	"context"
	"database/sql"
)

const createAuditEvent = `-- name: CreateAuditEvent :one
INSERT INTO audit_events (
    event_type,
    actor_user_id,
    target_user_id,
    entity_type,
    entity_id,
    action,
    details,
    ip_address,
    user_agent
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
RETURNING event_id, event_type, actor_user_id, target_user_id, entity_type, entity_id, "action", details, ip_address, user_agent, created_at
`

type CreateAuditEventParams struct {
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
}

func (q *Queries) CreateAuditEvent(ctx context.Context, arg CreateAuditEventParams) (AuditEvent, error) {
	row := q.db.QueryRowContext(ctx, createAuditEvent,
		arg.EventType,
		arg.ActorUserID,
		arg.TargetUserID,
		arg.EntityType,
		arg.EntityID,
		arg.Action,
		arg.Details,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i AuditEvent
	err := row.Scan(
		&i.EventID,
		&i.EventType,
		&i.ActorUserID,
		&i.TargetUserID,
		&i.EntityType,
		&i.EntityID,
		&i.Action,
		&i.Details,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditEventStats = `-- name: GetAuditEventStats :one
SELECT 
    COUNT(*) as total_events,
    COUNT(DISTINCT ae.actor_user_id) as unique_actors,
    COUNT(DISTINCT ae.event_type) as unique_event_types,
    MIN(ae.created_at) as earliest_event,
    MAX(ae.created_at) as latest_event
FROM audit_events ae
`

type GetAuditEventStatsRow struct {
	TotalEvents      int64       `json:"total_events"`
	UniqueActors     int64       `json:"unique_actors"`
	UniqueEventTypes int64       `json:"unique_event_types"`
	EarliestEvent    interface{} `json:"earliest_event"`
	LatestEvent      interface{} `json:"latest_event"`
}

func (q *Queries) GetAuditEventStats(ctx context.Context) (GetAuditEventStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAuditEventStats)
	var i GetAuditEventStatsRow
	err := row.Scan(
		&i.TotalEvents,
		&i.UniqueActors,
		&i.UniqueEventTypes,
		&i.EarliestEvent,
		&i.LatestEvent,
	)
	return i, err
}

const getAuditEventsByTypeStats = `-- name: GetAuditEventsByTypeStats :many
SELECT 
    event_type,
    COUNT(*) as event_count,
    MAX(created_at) as latest_event
FROM audit_events 
GROUP BY event_type
ORDER BY event_count DESC
`

type GetAuditEventsByTypeStatsRow struct {
	EventType   string      `json:"event_type"`
	EventCount  int64       `json:"event_count"`
	LatestEvent interface{} `json:"latest_event"`
}

func (q *Queries) GetAuditEventsByTypeStats(ctx context.Context) ([]GetAuditEventsByTypeStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAuditEventsByTypeStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditEventsByTypeStatsRow{}
	for rows.Next() {
		var i GetAuditEventsByTypeStatsRow
		if err := rows.Scan(&i.EventType, &i.EventCount, &i.LatestEvent); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEvents = `-- name: ListAuditEvents :many
SELECT 
    ae.event_id, ae.event_type, ae.actor_user_id, ae.target_user_id, ae.entity_type, ae.entity_id, ae."action", ae.details, ae.ip_address, ae.user_agent, ae.created_at,
    COALESCE(actor.name, '') as actor_name,
    actor.phone as actor_phone,
    COALESCE(target.name, '') as target_name,
    target.phone as target_phone
FROM audit_events ae
LEFT JOIN users actor ON ae.actor_user_id = actor.user_id
LEFT JOIN users target ON ae.target_user_id = target.user_id
ORDER BY ae.created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListAuditEventsRow struct {
	EventID      int64          `json:"event_id"`
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ActorName    string         `json:"actor_name"`
	ActorPhone   sql.NullString `json:"actor_phone"`
	TargetName   string         `json:"target_name"`
	TargetPhone  sql.NullString `json:"target_phone"`
}

func (q *Queries) ListAuditEvents(ctx context.Context, arg ListAuditEventsParams) ([]ListAuditEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditEventsRow{}
	for rows.Next() {
		var i ListAuditEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.ActorUserID,
			&i.TargetUserID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorPhone,
			&i.TargetName,
			&i.TargetPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByActor = `-- name: ListAuditEventsByActor :many
SELECT 
    ae.event_id, ae.event_type, ae.actor_user_id, ae.target_user_id, ae.entity_type, ae.entity_id, ae."action", ae.details, ae.ip_address, ae.user_agent, ae.created_at,
    COALESCE(actor.name, '') as actor_name,
    actor.phone as actor_phone,
    COALESCE(target.name, '') as target_name,
    target.phone as target_phone
FROM audit_events ae
LEFT JOIN users actor ON ae.actor_user_id = actor.user_id
LEFT JOIN users target ON ae.target_user_id = target.user_id
WHERE ae.actor_user_id = ?
ORDER BY ae.created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByActorParams struct {
	ActorUserID sql.NullInt64 `json:"actor_user_id"`
	Limit       int64         `json:"limit"`
	Offset      int64         `json:"offset"`
}

type ListAuditEventsByActorRow struct {
	EventID      int64          `json:"event_id"`
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ActorName    string         `json:"actor_name"`
	ActorPhone   sql.NullString `json:"actor_phone"`
	TargetName   string         `json:"target_name"`
	TargetPhone  sql.NullString `json:"target_phone"`
}

func (q *Queries) ListAuditEventsByActor(ctx context.Context, arg ListAuditEventsByActorParams) ([]ListAuditEventsByActorRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByActor, arg.ActorUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditEventsByActorRow{}
	for rows.Next() {
		var i ListAuditEventsByActorRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.ActorUserID,
			&i.TargetUserID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorPhone,
			&i.TargetName,
			&i.TargetPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByDateRange = `-- name: ListAuditEventsByDateRange :many
SELECT 
    ae.event_id, ae.event_type, ae.actor_user_id, ae.target_user_id, ae.entity_type, ae.entity_id, ae."action", ae.details, ae.ip_address, ae.user_agent, ae.created_at,
    COALESCE(actor.name, '') as actor_name,
    actor.phone as actor_phone,
    COALESCE(target.name, '') as target_name,
    target.phone as target_phone
FROM audit_events ae
LEFT JOIN users actor ON ae.actor_user_id = actor.user_id
LEFT JOIN users target ON ae.target_user_id = target.user_id
WHERE ae.created_at >= ? AND ae.created_at <= ?
ORDER BY ae.created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByDateRangeParams struct {
	CreatedAt   sql.NullTime `json:"created_at"`
	CreatedAt_2 sql.NullTime `json:"created_at_2"`
	Limit       int64        `json:"limit"`
	Offset      int64        `json:"offset"`
}

type ListAuditEventsByDateRangeRow struct {
	EventID      int64          `json:"event_id"`
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ActorName    string         `json:"actor_name"`
	ActorPhone   sql.NullString `json:"actor_phone"`
	TargetName   string         `json:"target_name"`
	TargetPhone  sql.NullString `json:"target_phone"`
}

func (q *Queries) ListAuditEventsByDateRange(ctx context.Context, arg ListAuditEventsByDateRangeParams) ([]ListAuditEventsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditEventsByDateRangeRow{}
	for rows.Next() {
		var i ListAuditEventsByDateRangeRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.ActorUserID,
			&i.TargetUserID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorPhone,
			&i.TargetName,
			&i.TargetPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByTarget = `-- name: ListAuditEventsByTarget :many
SELECT 
    ae.event_id, ae.event_type, ae.actor_user_id, ae.target_user_id, ae.entity_type, ae.entity_id, ae."action", ae.details, ae.ip_address, ae.user_agent, ae.created_at,
    COALESCE(actor.name, '') as actor_name,
    actor.phone as actor_phone,
    COALESCE(target.name, '') as target_name,
    target.phone as target_phone
FROM audit_events ae
LEFT JOIN users actor ON ae.actor_user_id = actor.user_id
LEFT JOIN users target ON ae.target_user_id = target.user_id
WHERE ae.target_user_id = ?
ORDER BY ae.created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByTargetParams struct {
	TargetUserID sql.NullInt64 `json:"target_user_id"`
	Limit        int64         `json:"limit"`
	Offset       int64         `json:"offset"`
}

type ListAuditEventsByTargetRow struct {
	EventID      int64          `json:"event_id"`
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ActorName    string         `json:"actor_name"`
	ActorPhone   sql.NullString `json:"actor_phone"`
	TargetName   string         `json:"target_name"`
	TargetPhone  sql.NullString `json:"target_phone"`
}

func (q *Queries) ListAuditEventsByTarget(ctx context.Context, arg ListAuditEventsByTargetParams) ([]ListAuditEventsByTargetRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByTarget, arg.TargetUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditEventsByTargetRow{}
	for rows.Next() {
		var i ListAuditEventsByTargetRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.ActorUserID,
			&i.TargetUserID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorPhone,
			&i.TargetName,
			&i.TargetPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsByType = `-- name: ListAuditEventsByType :many
SELECT 
    ae.event_id, ae.event_type, ae.actor_user_id, ae.target_user_id, ae.entity_type, ae.entity_id, ae."action", ae.details, ae.ip_address, ae.user_agent, ae.created_at,
    COALESCE(actor.name, '') as actor_name,
    actor.phone as actor_phone,
    COALESCE(target.name, '') as target_name,
    target.phone as target_phone
FROM audit_events ae
LEFT JOIN users actor ON ae.actor_user_id = actor.user_id
LEFT JOIN users target ON ae.target_user_id = target.user_id
WHERE ae.event_type = ?
ORDER BY ae.created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsByTypeParams struct {
	EventType string `json:"event_type"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

type ListAuditEventsByTypeRow struct {
	EventID      int64          `json:"event_id"`
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ActorName    string         `json:"actor_name"`
	ActorPhone   sql.NullString `json:"actor_phone"`
	TargetName   string         `json:"target_name"`
	TargetPhone  sql.NullString `json:"target_phone"`
}

func (q *Queries) ListAuditEventsByType(ctx context.Context, arg ListAuditEventsByTypeParams) ([]ListAuditEventsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsByType, arg.EventType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditEventsByTypeRow{}
	for rows.Next() {
		var i ListAuditEventsByTypeRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.ActorUserID,
			&i.TargetUserID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorPhone,
			&i.TargetName,
			&i.TargetPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditEventsWithFilters = `-- name: ListAuditEventsWithFilters :many
SELECT 
    ae.event_id, ae.event_type, ae.actor_user_id, ae.target_user_id, ae.entity_type, ae.entity_id, ae."action", ae.details, ae.ip_address, ae.user_agent, ae.created_at,
    COALESCE(actor.name, '') as actor_name,
    actor.phone as actor_phone,
    COALESCE(target.name, '') as target_name,
    target.phone as target_phone
FROM audit_events ae
LEFT JOIN users actor ON ae.actor_user_id = actor.user_id
LEFT JOIN users target ON ae.target_user_id = target.user_id
WHERE (? = '' OR ae.event_type = ?)
  AND (? = '' OR ae.actor_user_id IN (SELECT value FROM json_each(?)))
  AND (? = '' OR ae.target_user_id IN (SELECT value FROM json_each(?)))
ORDER BY ae.created_at DESC
LIMIT ? OFFSET ?
`

type ListAuditEventsWithFiltersParams struct {
	Column1   interface{} `json:"column_1"`
	EventType string      `json:"event_type"`
	Column3   interface{} `json:"column_3"`
	Column4   interface{} `json:"column_4"`
	Limit     int64       `json:"limit"`
	Offset    int64       `json:"offset"`
}

type ListAuditEventsWithFiltersRow struct {
	EventID      int64          `json:"event_id"`
	EventType    string         `json:"event_type"`
	ActorUserID  sql.NullInt64  `json:"actor_user_id"`
	TargetUserID sql.NullInt64  `json:"target_user_id"`
	EntityType   string         `json:"entity_type"`
	EntityID     sql.NullInt64  `json:"entity_id"`
	Action       string         `json:"action"`
	Details      sql.NullString `json:"details"`
	IpAddress    sql.NullString `json:"ip_address"`
	UserAgent    sql.NullString `json:"user_agent"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	ActorName    string         `json:"actor_name"`
	ActorPhone   sql.NullString `json:"actor_phone"`
	TargetName   string         `json:"target_name"`
	TargetPhone  sql.NullString `json:"target_phone"`
}

func (q *Queries) ListAuditEventsWithFilters(ctx context.Context, arg ListAuditEventsWithFiltersParams) ([]ListAuditEventsWithFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAuditEventsWithFilters,
		arg.Column1,
		arg.EventType,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditEventsWithFiltersRow{}
	for rows.Next() {
		var i ListAuditEventsWithFiltersRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventType,
			&i.ActorUserID,
			&i.TargetUserID,
			&i.EntityType,
			&i.EntityID,
			&i.Action,
			&i.Details,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorPhone,
			&i.TargetName,
			&i.TargetPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
