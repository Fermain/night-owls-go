// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: calendar_tokens.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const cleanupExpiredCalendarTokens = `-- name: CleanupExpiredCalendarTokens :exec
DELETE FROM calendar_tokens 
WHERE expires_at < datetime('now', '-30 days')
`

func (q *Queries) CleanupExpiredCalendarTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredCalendarTokens)
	return err
}

const createCalendarToken = `-- name: CreateCalendarToken :one

INSERT INTO calendar_tokens (
    user_id,
    token_hash,
    expires_at
) VALUES (?, ?, ?)
RETURNING token_id, user_id, token_hash, created_at, expires_at, last_accessed_at, access_count, is_revoked
`

type CreateCalendarTokenParams struct {
	UserID    int64     `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

// Calendar Token Queries
func (q *Queries) CreateCalendarToken(ctx context.Context, arg CreateCalendarTokenParams) (CalendarToken, error) {
	row := q.db.QueryRowContext(ctx, createCalendarToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	var i CalendarToken
	err := row.Scan(
		&i.TokenID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessedAt,
		&i.AccessCount,
		&i.IsRevoked,
	)
	return i, err
}

const getCalendarTokenByHash = `-- name: GetCalendarTokenByHash :one
SELECT token_id, user_id, token_hash, created_at, expires_at, last_accessed_at, access_count, is_revoked FROM calendar_tokens 
WHERE token_hash = ? 
  AND is_revoked = 0 
  AND expires_at > datetime('now')
`

func (q *Queries) GetCalendarTokenByHash(ctx context.Context, tokenHash string) (CalendarToken, error) {
	row := q.db.QueryRowContext(ctx, getCalendarTokenByHash, tokenHash)
	var i CalendarToken
	err := row.Scan(
		&i.TokenID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessedAt,
		&i.AccessCount,
		&i.IsRevoked,
	)
	return i, err
}

const getCalendarTokenStats = `-- name: GetCalendarTokenStats :one

SELECT 
    COUNT(*) as total_tokens,
    COUNT(CASE WHEN is_revoked = 0 THEN 1 END) as active_tokens,
    COUNT(CASE WHEN expires_at < datetime('now') THEN 1 END) as expired_tokens,
    COUNT(CASE WHEN last_accessed_at IS NOT NULL THEN 1 END) as used_tokens
FROM calendar_tokens
`

type GetCalendarTokenStatsRow struct {
	TotalTokens   int64 `json:"total_tokens"`
	ActiveTokens  int64 `json:"active_tokens"`
	ExpiredTokens int64 `json:"expired_tokens"`
	UsedTokens    int64 `json:"used_tokens"`
}

// Keep expired tokens for 30 days for audit
func (q *Queries) GetCalendarTokenStats(ctx context.Context) (GetCalendarTokenStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getCalendarTokenStats)
	var i GetCalendarTokenStatsRow
	err := row.Scan(
		&i.TotalTokens,
		&i.ActiveTokens,
		&i.ExpiredTokens,
		&i.UsedTokens,
	)
	return i, err
}

const getUserCalendarTokens = `-- name: GetUserCalendarTokens :many
SELECT token_id, created_at, expires_at, last_accessed_at, access_count, is_revoked
FROM calendar_tokens 
WHERE user_id = ?
ORDER BY created_at DESC
`

type GetUserCalendarTokensRow struct {
	TokenID        int64         `json:"token_id"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	ExpiresAt      time.Time     `json:"expires_at"`
	LastAccessedAt sql.NullTime  `json:"last_accessed_at"`
	AccessCount    sql.NullInt64 `json:"access_count"`
	IsRevoked      sql.NullBool  `json:"is_revoked"`
}

func (q *Queries) GetUserCalendarTokens(ctx context.Context, userID int64) ([]GetUserCalendarTokensRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCalendarTokens, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCalendarTokensRow{}
	for rows.Next() {
		var i GetUserCalendarTokensRow
		if err := rows.Scan(
			&i.TokenID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastAccessedAt,
			&i.AccessCount,
			&i.IsRevoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllUserCalendarTokens = `-- name: RevokeAllUserCalendarTokens :exec
UPDATE calendar_tokens 
SET is_revoked = 1
WHERE user_id = ?
`

func (q *Queries) RevokeAllUserCalendarTokens(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, revokeAllUserCalendarTokens, userID)
	return err
}

const revokeCalendarToken = `-- name: RevokeCalendarToken :exec
UPDATE calendar_tokens 
SET is_revoked = 1
WHERE user_id = ? AND token_hash = ?
`

type RevokeCalendarTokenParams struct {
	UserID    int64  `json:"user_id"`
	TokenHash string `json:"token_hash"`
}

func (q *Queries) RevokeCalendarToken(ctx context.Context, arg RevokeCalendarTokenParams) error {
	_, err := q.db.ExecContext(ctx, revokeCalendarToken, arg.UserID, arg.TokenHash)
	return err
}

const updateTokenAccess = `-- name: UpdateTokenAccess :exec
UPDATE calendar_tokens 
SET last_accessed_at = datetime('now'),
    access_count = access_count + 1
WHERE token_hash = ?
`

func (q *Queries) UpdateTokenAccess(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, updateTokenAccess, tokenHash)
	return err
}

const validateCalendarToken = `-- name: ValidateCalendarToken :one
SELECT ct.token_id, ct.user_id, ct.token_hash, ct.created_at, ct.expires_at, ct.last_accessed_at, ct.access_count, ct.is_revoked, u.name as user_name 
FROM calendar_tokens ct
JOIN users u ON ct.user_id = u.user_id
WHERE ct.user_id = ? 
  AND ct.token_hash = ? 
  AND ct.is_revoked = 0 
  AND ct.expires_at > datetime('now')
`

type ValidateCalendarTokenParams struct {
	UserID    int64  `json:"user_id"`
	TokenHash string `json:"token_hash"`
}

type ValidateCalendarTokenRow struct {
	TokenID        int64          `json:"token_id"`
	UserID         int64          `json:"user_id"`
	TokenHash      string         `json:"token_hash"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	ExpiresAt      time.Time      `json:"expires_at"`
	LastAccessedAt sql.NullTime   `json:"last_accessed_at"`
	AccessCount    sql.NullInt64  `json:"access_count"`
	IsRevoked      sql.NullBool   `json:"is_revoked"`
	UserName       sql.NullString `json:"user_name"`
}

func (q *Queries) ValidateCalendarToken(ctx context.Context, arg ValidateCalendarTokenParams) (ValidateCalendarTokenRow, error) {
	row := q.db.QueryRowContext(ctx, validateCalendarToken, arg.UserID, arg.TokenHash)
	var i ValidateCalendarTokenRow
	err := row.Scan(
		&i.TokenID,
		&i.UserID,
		&i.TokenHash,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessedAt,
		&i.AccessCount,
		&i.IsRevoked,
		&i.UserName,
	)
	return i, err
}
