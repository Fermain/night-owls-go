// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recurring_assignments.sql

package db

import (
	"context"
	"database/sql"
)

const createRecurringAssignment = `-- name: CreateRecurringAssignment :one
INSERT INTO recurring_assignments (
    user_id,
    buddy_name,
    day_of_week,
    schedule_id,
    time_slot,
    description
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
RETURNING recurring_assignment_id, user_id, buddy_name, day_of_week, schedule_id, time_slot, description, is_active, created_at, updated_at
`

type CreateRecurringAssignmentParams struct {
	UserID      int64          `json:"user_id"`
	BuddyName   sql.NullString `json:"buddy_name"`
	DayOfWeek   int64          `json:"day_of_week"`
	ScheduleID  int64          `json:"schedule_id"`
	TimeSlot    string         `json:"time_slot"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateRecurringAssignment(ctx context.Context, arg CreateRecurringAssignmentParams) (RecurringAssignment, error) {
	row := q.db.QueryRowContext(ctx, createRecurringAssignment,
		arg.UserID,
		arg.BuddyName,
		arg.DayOfWeek,
		arg.ScheduleID,
		arg.TimeSlot,
		arg.Description,
	)
	var i RecurringAssignment
	err := row.Scan(
		&i.RecurringAssignmentID,
		&i.UserID,
		&i.BuddyName,
		&i.DayOfWeek,
		&i.ScheduleID,
		&i.TimeSlot,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecurringAssignment = `-- name: DeleteRecurringAssignment :exec
UPDATE recurring_assignments
SET is_active = 0, updated_at = CURRENT_TIMESTAMP
WHERE recurring_assignment_id = ?
`

func (q *Queries) DeleteRecurringAssignment(ctx context.Context, recurringAssignmentID int64) error {
	_, err := q.db.ExecContext(ctx, deleteRecurringAssignment, recurringAssignmentID)
	return err
}

const getRecurringAssignmentByID = `-- name: GetRecurringAssignmentByID :one
SELECT recurring_assignment_id, user_id, buddy_name, day_of_week, schedule_id, time_slot, description, is_active, created_at, updated_at FROM recurring_assignments
WHERE recurring_assignment_id = ?
`

func (q *Queries) GetRecurringAssignmentByID(ctx context.Context, recurringAssignmentID int64) (RecurringAssignment, error) {
	row := q.db.QueryRowContext(ctx, getRecurringAssignmentByID, recurringAssignmentID)
	var i RecurringAssignment
	err := row.Scan(
		&i.RecurringAssignmentID,
		&i.UserID,
		&i.BuddyName,
		&i.DayOfWeek,
		&i.ScheduleID,
		&i.TimeSlot,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecurringAssignmentsByPattern = `-- name: GetRecurringAssignmentsByPattern :many
SELECT ra.recurring_assignment_id, ra.user_id, ra.buddy_name, ra.day_of_week, ra.schedule_id, ra.time_slot, ra.description, ra.is_active, ra.created_at, ra.updated_at, u.name as user_name, u.phone as user_phone, s.name as schedule_name
FROM recurring_assignments ra
JOIN users u ON ra.user_id = u.user_id
JOIN schedules s ON ra.schedule_id = s.schedule_id
WHERE ra.day_of_week = ? 
  AND ra.schedule_id = ? 
  AND ra.time_slot = ? 
  AND ra.is_active = 1
`

type GetRecurringAssignmentsByPatternParams struct {
	DayOfWeek  int64  `json:"day_of_week"`
	ScheduleID int64  `json:"schedule_id"`
	TimeSlot   string `json:"time_slot"`
}

type GetRecurringAssignmentsByPatternRow struct {
	RecurringAssignmentID int64          `json:"recurring_assignment_id"`
	UserID                int64          `json:"user_id"`
	BuddyName             sql.NullString `json:"buddy_name"`
	DayOfWeek             int64          `json:"day_of_week"`
	ScheduleID            int64          `json:"schedule_id"`
	TimeSlot              string         `json:"time_slot"`
	Description           sql.NullString `json:"description"`
	IsActive              bool           `json:"is_active"`
	CreatedAt             sql.NullTime   `json:"created_at"`
	UpdatedAt             sql.NullTime   `json:"updated_at"`
	UserName              sql.NullString `json:"user_name"`
	UserPhone             string         `json:"user_phone"`
	ScheduleName          string         `json:"schedule_name"`
}

func (q *Queries) GetRecurringAssignmentsByPattern(ctx context.Context, arg GetRecurringAssignmentsByPatternParams) ([]GetRecurringAssignmentsByPatternRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecurringAssignmentsByPattern, arg.DayOfWeek, arg.ScheduleID, arg.TimeSlot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecurringAssignmentsByPatternRow{}
	for rows.Next() {
		var i GetRecurringAssignmentsByPatternRow
		if err := rows.Scan(
			&i.RecurringAssignmentID,
			&i.UserID,
			&i.BuddyName,
			&i.DayOfWeek,
			&i.ScheduleID,
			&i.TimeSlot,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.UserPhone,
			&i.ScheduleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringAssignments = `-- name: ListRecurringAssignments :many
SELECT recurring_assignment_id, user_id, buddy_name, day_of_week, schedule_id, time_slot, description, is_active, created_at, updated_at FROM recurring_assignments
WHERE is_active = 1
ORDER BY day_of_week, time_slot
`

func (q *Queries) ListRecurringAssignments(ctx context.Context) ([]RecurringAssignment, error) {
	rows, err := q.db.QueryContext(ctx, listRecurringAssignments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringAssignment{}
	for rows.Next() {
		var i RecurringAssignment
		if err := rows.Scan(
			&i.RecurringAssignmentID,
			&i.UserID,
			&i.BuddyName,
			&i.DayOfWeek,
			&i.ScheduleID,
			&i.TimeSlot,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringAssignmentsByUserID = `-- name: ListRecurringAssignmentsByUserID :many
SELECT recurring_assignment_id, user_id, buddy_name, day_of_week, schedule_id, time_slot, description, is_active, created_at, updated_at FROM recurring_assignments
WHERE user_id = ? AND is_active = 1
ORDER BY day_of_week, time_slot
`

func (q *Queries) ListRecurringAssignmentsByUserID(ctx context.Context, userID int64) ([]RecurringAssignment, error) {
	rows, err := q.db.QueryContext(ctx, listRecurringAssignmentsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringAssignment{}
	for rows.Next() {
		var i RecurringAssignment
		if err := rows.Scan(
			&i.RecurringAssignmentID,
			&i.UserID,
			&i.BuddyName,
			&i.DayOfWeek,
			&i.ScheduleID,
			&i.TimeSlot,
			&i.Description,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecurringAssignment = `-- name: UpdateRecurringAssignment :one
UPDATE recurring_assignments
SET
    user_id = ?,
    buddy_name = ?,
    day_of_week = ?,
    schedule_id = ?,
    time_slot = ?,
    description = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE
    recurring_assignment_id = ?
RETURNING recurring_assignment_id, user_id, buddy_name, day_of_week, schedule_id, time_slot, description, is_active, created_at, updated_at
`

type UpdateRecurringAssignmentParams struct {
	UserID                int64          `json:"user_id"`
	BuddyName             sql.NullString `json:"buddy_name"`
	DayOfWeek             int64          `json:"day_of_week"`
	ScheduleID            int64          `json:"schedule_id"`
	TimeSlot              string         `json:"time_slot"`
	Description           sql.NullString `json:"description"`
	RecurringAssignmentID int64          `json:"recurring_assignment_id"`
}

func (q *Queries) UpdateRecurringAssignment(ctx context.Context, arg UpdateRecurringAssignmentParams) (RecurringAssignment, error) {
	row := q.db.QueryRowContext(ctx, updateRecurringAssignment,
		arg.UserID,
		arg.BuddyName,
		arg.DayOfWeek,
		arg.ScheduleID,
		arg.TimeSlot,
		arg.Description,
		arg.RecurringAssignmentID,
	)
	var i RecurringAssignment
	err := row.Scan(
		&i.RecurringAssignmentID,
		&i.UserID,
		&i.BuddyName,
		&i.DayOfWeek,
		&i.ScheduleID,
		&i.TimeSlot,
		&i.Description,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
