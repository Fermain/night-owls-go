// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: points.sql

package db

import (
	"context"
	"database/sql"
)

const awardAchievement = `-- name: AwardAchievement :exec
INSERT OR IGNORE INTO user_achievements (user_id, achievement_id)
VALUES (?, ?)
`

type AwardAchievementParams struct {
	UserID        int64 `json:"user_id"`
	AchievementID int64 `json:"achievement_id"`
}

// Award an achievement to a user
func (q *Queries) AwardAchievement(ctx context.Context, arg AwardAchievementParams) error {
	_, err := q.db.ExecContext(ctx, awardAchievement, arg.UserID, arg.AchievementID)
	return err
}

const awardPoints = `-- name: AwardPoints :exec

INSERT INTO points_history (user_id, booking_id, points_awarded, reason, multiplier)
VALUES (?, ?, ?, ?, ?)
`

type AwardPointsParams struct {
	UserID        int64           `json:"user_id"`
	BookingID     sql.NullInt64   `json:"booking_id"`
	PointsAwarded int64           `json:"points_awarded"`
	Reason        string          `json:"reason"`
	Multiplier    sql.NullFloat64 `json:"multiplier"`
}

// Points System Queries
// Award points to a user for a specific reason
func (q *Queries) AwardPoints(ctx context.Context, arg AwardPointsParams) error {
	_, err := q.db.ExecContext(ctx, awardPoints,
		arg.UserID,
		arg.BookingID,
		arg.PointsAwarded,
		arg.Reason,
		arg.Multiplier,
	)
	return err
}

const getAvailableAchievements = `-- name: GetAvailableAchievements :many
SELECT 
    a.achievement_id,
    a.name,
    a.description,
    a.icon,
    a.points_threshold,
    a.streak_threshold
FROM achievements a
WHERE a.achievement_id NOT IN (
    SELECT ua.achievement_id 
    FROM user_achievements ua 
    WHERE ua.user_id = ?
)
ORDER BY 
    CASE WHEN a.points_threshold IS NOT NULL THEN a.points_threshold ELSE 9999 END,
    CASE WHEN a.streak_threshold IS NOT NULL THEN a.streak_threshold ELSE 9999 END
`

type GetAvailableAchievementsRow struct {
	AchievementID   int64          `json:"achievement_id"`
	Name            string         `json:"name"`
	Description     string         `json:"description"`
	Icon            sql.NullString `json:"icon"`
	PointsThreshold sql.NullInt64  `json:"points_threshold"`
	StreakThreshold sql.NullInt64  `json:"streak_threshold"`
}

// Get achievements a user hasn't earned yet
func (q *Queries) GetAvailableAchievements(ctx context.Context, userID int64) ([]GetAvailableAchievementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableAchievements, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableAchievementsRow{}
	for rows.Next() {
		var i GetAvailableAchievementsRow
		if err := rows.Scan(
			&i.AchievementID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.PointsThreshold,
			&i.StreakThreshold,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActivity = `-- name: GetRecentActivity :many
SELECT 
    u.name,
    ph.points_awarded,
    ph.reason,
    ph.created_at,
    -- Anonymize for privacy while keeping engagement
    CASE 
        WHEN ph.points_awarded >= 50 THEN 'major'
        WHEN ph.points_awarded >= 20 THEN 'significant'
        ELSE 'standard'
    END as activity_type
FROM points_history ph
JOIN users u ON ph.user_id = u.user_id
WHERE ph.created_at >= datetime('now', '-24 hours')
    AND u.role IN ('admin', 'owl')
ORDER BY ph.created_at DESC
LIMIT ?
`

type GetRecentActivityRow struct {
	Name          sql.NullString `json:"name"`
	PointsAwarded int64          `json:"points_awarded"`
	Reason        string         `json:"reason"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	ActivityType  string         `json:"activity_type"`
}

// Get recent point-earning activities across all users for activity feed
func (q *Queries) GetRecentActivity(ctx context.Context, limit int64) ([]GetRecentActivityRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentActivity, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentActivityRow{}
	for rows.Next() {
		var i GetRecentActivityRow
		if err := rows.Scan(
			&i.Name,
			&i.PointsAwarded,
			&i.Reason,
			&i.CreatedAt,
			&i.ActivityType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStreakLeaderboard = `-- name: GetStreakLeaderboard :many
SELECT 
    u.user_id,
    u.name,
    u.current_streak,
    u.total_points,
    COUNT(DISTINCT ua.achievement_id) as achievement_count
FROM users u
LEFT JOIN user_achievements ua ON u.user_id = ua.user_id
WHERE u.role IN ('admin', 'owl') AND u.current_streak > 0
GROUP BY u.user_id, u.name, u.current_streak, u.total_points
ORDER BY u.current_streak DESC, u.total_points DESC
LIMIT ?
`

type GetStreakLeaderboardRow struct {
	UserID           int64          `json:"user_id"`
	Name             sql.NullString `json:"name"`
	CurrentStreak    sql.NullInt64  `json:"current_streak"`
	TotalPoints      sql.NullInt64  `json:"total_points"`
	AchievementCount int64          `json:"achievement_count"`
}

// Get leaderboard by current streak
func (q *Queries) GetStreakLeaderboard(ctx context.Context, limit int64) ([]GetStreakLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getStreakLeaderboard, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStreakLeaderboardRow{}
	for rows.Next() {
		var i GetStreakLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.CurrentStreak,
			&i.TotalPoints,
			&i.AchievementCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsers = `-- name: GetTopUsers :many
SELECT 
    u.user_id,
    u.name,
    u.total_points,
    u.current_streak,
    u.longest_streak,
    COUNT(DISTINCT ua.achievement_id) as achievement_count,
    -- Recent activity indicator
    CASE 
        WHEN u.last_activity_date >= DATE('now', '-7 days') THEN 'active'
        WHEN u.last_activity_date >= DATE('now', '-30 days') THEN 'moderate' 
        ELSE 'inactive'
    END as activity_status
FROM users u
LEFT JOIN user_achievements ua ON u.user_id = ua.user_id
WHERE u.role IN ('admin', 'owl') AND u.total_points > 0
GROUP BY u.user_id, u.name, u.total_points, u.current_streak, u.longest_streak, u.last_activity_date
ORDER BY u.total_points DESC, u.current_streak DESC
LIMIT ?
`

type GetTopUsersRow struct {
	UserID           int64          `json:"user_id"`
	Name             sql.NullString `json:"name"`
	TotalPoints      sql.NullInt64  `json:"total_points"`
	CurrentStreak    sql.NullInt64  `json:"current_streak"`
	LongestStreak    sql.NullInt64  `json:"longest_streak"`
	AchievementCount int64          `json:"achievement_count"`
	ActivityStatus   string         `json:"activity_status"`
}

// Get leaderboard of top users by points
func (q *Queries) GetTopUsers(ctx context.Context, limit int64) ([]GetTopUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopUsers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopUsersRow{}
	for rows.Next() {
		var i GetTopUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.TotalPoints,
			&i.CurrentStreak,
			&i.LongestStreak,
			&i.AchievementCount,
			&i.ActivityStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAchievements = `-- name: GetUserAchievements :many
SELECT 
    a.achievement_id,
    a.name,
    a.description,
    a.icon,
    ua.earned_at
FROM achievements a
JOIN user_achievements ua ON a.achievement_id = ua.achievement_id
WHERE ua.user_id = ?
ORDER BY ua.earned_at DESC
`

type GetUserAchievementsRow struct {
	AchievementID int64          `json:"achievement_id"`
	Name          string         `json:"name"`
	Description   string         `json:"description"`
	Icon          sql.NullString `json:"icon"`
	EarnedAt      sql.NullTime   `json:"earned_at"`
}

// Get all achievements earned by a user
func (q *Queries) GetUserAchievements(ctx context.Context, userID int64) ([]GetUserAchievementsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAchievements, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserAchievementsRow{}
	for rows.Next() {
		var i GetUserAchievementsRow
		if err := rows.Scan(
			&i.AchievementID,
			&i.Name,
			&i.Description,
			&i.Icon,
			&i.EarnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPoints = `-- name: GetUserPoints :one
SELECT 
    user_id,
    name,
    total_points,
    current_streak,
    longest_streak,
    last_activity_date
FROM users 
WHERE user_id = ?
`

type GetUserPointsRow struct {
	UserID           int64          `json:"user_id"`
	Name             sql.NullString `json:"name"`
	TotalPoints      sql.NullInt64  `json:"total_points"`
	CurrentStreak    sql.NullInt64  `json:"current_streak"`
	LongestStreak    sql.NullInt64  `json:"longest_streak"`
	LastActivityDate sql.NullTime   `json:"last_activity_date"`
}

// Get a user's current points and streak information
func (q *Queries) GetUserPoints(ctx context.Context, userID int64) (GetUserPointsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserPoints, userID)
	var i GetUserPointsRow
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.TotalPoints,
		&i.CurrentStreak,
		&i.LongestStreak,
		&i.LastActivityDate,
	)
	return i, err
}

const getUserPointsHistory = `-- name: GetUserPointsHistory :many
SELECT 
    ph.points_awarded,
    ph.reason,
    ph.multiplier,
    ph.created_at,
    b.shift_start
FROM points_history ph
LEFT JOIN bookings b ON ph.booking_id = b.booking_id
WHERE ph.user_id = ?
ORDER BY ph.created_at DESC
LIMIT ?
`

type GetUserPointsHistoryParams struct {
	UserID int64 `json:"user_id"`
	Limit  int64 `json:"limit"`
}

type GetUserPointsHistoryRow struct {
	PointsAwarded int64           `json:"points_awarded"`
	Reason        string          `json:"reason"`
	Multiplier    sql.NullFloat64 `json:"multiplier"`
	CreatedAt     sql.NullTime    `json:"created_at"`
	ShiftStart    sql.NullTime    `json:"shift_start"`
}

// Get recent points history for a user
func (q *Queries) GetUserPointsHistory(ctx context.Context, arg GetUserPointsHistoryParams) ([]GetUserPointsHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserPointsHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPointsHistoryRow{}
	for rows.Next() {
		var i GetUserPointsHistoryRow
		if err := rows.Scan(
			&i.PointsAwarded,
			&i.Reason,
			&i.Multiplier,
			&i.CreatedAt,
			&i.ShiftStart,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRank = `-- name: GetUserRank :one
SELECT 
    COUNT(*) + 1 as user_rank
FROM users 
WHERE role IN ('admin', 'owl') 
    AND total_points > (SELECT u2.total_points FROM users u2 WHERE u2.user_id = ?)
    AND total_points > 0
`

// Get a specific user's rank
func (q *Queries) GetUserRank(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserRank, userID)
	var user_rank int64
	err := row.Scan(&user_rank)
	return user_rank, err
}

const updateUserStreak = `-- name: UpdateUserStreak :exec
UPDATE users 
SET current_streak = ?, 
    longest_streak = CASE WHEN ? > longest_streak THEN ? ELSE longest_streak END,
    last_activity_date = DATE('now')
WHERE user_id = ?
`

type UpdateUserStreakParams struct {
	CurrentStreak   sql.NullInt64 `json:"current_streak"`
	LongestStreak   sql.NullInt64 `json:"longest_streak"`
	LongestStreak_2 sql.NullInt64 `json:"longest_streak_2"`
	UserID          int64         `json:"user_id"`
}

// Update user's current and longest streak
func (q *Queries) UpdateUserStreak(ctx context.Context, arg UpdateUserStreakParams) error {
	_, err := q.db.ExecContext(ctx, updateUserStreak,
		arg.CurrentStreak,
		arg.LongestStreak,
		arg.LongestStreak_2,
		arg.UserID,
	)
	return err
}

const updateUserTotalPoints = `-- name: UpdateUserTotalPoints :exec
UPDATE users 
SET total_points = (
    SELECT COALESCE(SUM(ph.points_awarded * ph.multiplier), 0) 
    FROM points_history ph
    WHERE ph.user_id = ?
)
WHERE users.user_id = ?
`

type UpdateUserTotalPointsParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

// Update user's total points (should be called after AwardPoints)
func (q *Queries) UpdateUserTotalPoints(ctx context.Context, arg UpdateUserTotalPointsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserTotalPoints, arg.UserID, arg.UserID_2)
	return err
}
