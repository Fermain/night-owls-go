// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: broadcasts.sql

package db

import (
	"context"
	"database/sql"
)

const createBroadcast = `-- name: CreateBroadcast :one
INSERT INTO broadcasts (
    message,
    audience,
    sender_user_id,
    push_enabled,
    scheduled_at,
    recipient_count
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
RETURNING broadcast_id, message, audience, sender_user_id, push_enabled, scheduled_at, sent_at, status, recipient_count, sent_count, failed_count, created_at
`

type CreateBroadcastParams struct {
	Message        string        `json:"message"`
	Audience       string        `json:"audience"`
	SenderUserID   int64         `json:"sender_user_id"`
	PushEnabled    bool          `json:"push_enabled"`
	ScheduledAt    sql.NullTime  `json:"scheduled_at"`
	RecipientCount sql.NullInt64 `json:"recipient_count"`
}

func (q *Queries) CreateBroadcast(ctx context.Context, arg CreateBroadcastParams) (Broadcast, error) {
	row := q.db.QueryRowContext(ctx, createBroadcast,
		arg.Message,
		arg.Audience,
		arg.SenderUserID,
		arg.PushEnabled,
		arg.ScheduledAt,
		arg.RecipientCount,
	)
	var i Broadcast
	err := row.Scan(
		&i.BroadcastID,
		&i.Message,
		&i.Audience,
		&i.SenderUserID,
		&i.PushEnabled,
		&i.ScheduledAt,
		&i.SentAt,
		&i.Status,
		&i.RecipientCount,
		&i.SentCount,
		&i.FailedCount,
		&i.CreatedAt,
	)
	return i, err
}

const getBroadcastByID = `-- name: GetBroadcastByID :one
SELECT broadcast_id, message, audience, sender_user_id, push_enabled, scheduled_at, sent_at, status, recipient_count, sent_count, failed_count, created_at FROM broadcasts
WHERE broadcast_id = ?
`

func (q *Queries) GetBroadcastByID(ctx context.Context, broadcastID int64) (Broadcast, error) {
	row := q.db.QueryRowContext(ctx, getBroadcastByID, broadcastID)
	var i Broadcast
	err := row.Scan(
		&i.BroadcastID,
		&i.Message,
		&i.Audience,
		&i.SenderUserID,
		&i.PushEnabled,
		&i.ScheduledAt,
		&i.SentAt,
		&i.Status,
		&i.RecipientCount,
		&i.SentCount,
		&i.FailedCount,
		&i.CreatedAt,
	)
	return i, err
}

const listBroadcasts = `-- name: ListBroadcasts :many
SELECT broadcast_id, message, audience, sender_user_id, push_enabled, scheduled_at, sent_at, status, recipient_count, sent_count, failed_count, created_at FROM broadcasts
ORDER BY created_at DESC
`

func (q *Queries) ListBroadcasts(ctx context.Context) ([]Broadcast, error) {
	rows, err := q.db.QueryContext(ctx, listBroadcasts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Broadcast{}
	for rows.Next() {
		var i Broadcast
		if err := rows.Scan(
			&i.BroadcastID,
			&i.Message,
			&i.Audience,
			&i.SenderUserID,
			&i.PushEnabled,
			&i.ScheduledAt,
			&i.SentAt,
			&i.Status,
			&i.RecipientCount,
			&i.SentCount,
			&i.FailedCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBroadcastsWithSender = `-- name: ListBroadcastsWithSender :many
SELECT 
    b.broadcast_id,
    b.message,
    b.audience,
    b.sender_user_id,
    b.push_enabled,
    b.scheduled_at,
    b.sent_at,
    b.status,
    b.recipient_count,
    b.sent_count,
    b.failed_count,
    b.created_at,
    COALESCE(u.name, 'Unknown User') as sender_name
FROM broadcasts b
LEFT JOIN users u ON b.sender_user_id = u.user_id
ORDER BY b.created_at DESC
`

type ListBroadcastsWithSenderRow struct {
	BroadcastID    int64         `json:"broadcast_id"`
	Message        string        `json:"message"`
	Audience       string        `json:"audience"`
	SenderUserID   int64         `json:"sender_user_id"`
	PushEnabled    bool          `json:"push_enabled"`
	ScheduledAt    sql.NullTime  `json:"scheduled_at"`
	SentAt         sql.NullTime  `json:"sent_at"`
	Status         string        `json:"status"`
	RecipientCount sql.NullInt64 `json:"recipient_count"`
	SentCount      sql.NullInt64 `json:"sent_count"`
	FailedCount    sql.NullInt64 `json:"failed_count"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	SenderName     string        `json:"sender_name"`
}

func (q *Queries) ListBroadcastsWithSender(ctx context.Context) ([]ListBroadcastsWithSenderRow, error) {
	rows, err := q.db.QueryContext(ctx, listBroadcastsWithSender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBroadcastsWithSenderRow{}
	for rows.Next() {
		var i ListBroadcastsWithSenderRow
		if err := rows.Scan(
			&i.BroadcastID,
			&i.Message,
			&i.Audience,
			&i.SenderUserID,
			&i.PushEnabled,
			&i.ScheduledAt,
			&i.SentAt,
			&i.Status,
			&i.RecipientCount,
			&i.SentCount,
			&i.FailedCount,
			&i.CreatedAt,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingBroadcasts = `-- name: ListPendingBroadcasts :many
SELECT broadcast_id, message, audience, sender_user_id, push_enabled, scheduled_at, sent_at, status, recipient_count, sent_count, failed_count, created_at FROM broadcasts
WHERE status = 'pending'
AND (scheduled_at IS NULL OR scheduled_at <= datetime('now'))
ORDER BY created_at ASC
`

func (q *Queries) ListPendingBroadcasts(ctx context.Context) ([]Broadcast, error) {
	rows, err := q.db.QueryContext(ctx, listPendingBroadcasts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Broadcast{}
	for rows.Next() {
		var i Broadcast
		if err := rows.Scan(
			&i.BroadcastID,
			&i.Message,
			&i.Audience,
			&i.SenderUserID,
			&i.PushEnabled,
			&i.ScheduledAt,
			&i.SentAt,
			&i.Status,
			&i.RecipientCount,
			&i.SentCount,
			&i.FailedCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBroadcastStatus = `-- name: UpdateBroadcastStatus :one
UPDATE broadcasts
SET
    status = ?,
    sent_at = ?,
    sent_count = ?,
    failed_count = ?
WHERE
    broadcast_id = ?
RETURNING broadcast_id, message, audience, sender_user_id, push_enabled, scheduled_at, sent_at, status, recipient_count, sent_count, failed_count, created_at
`

type UpdateBroadcastStatusParams struct {
	Status      string        `json:"status"`
	SentAt      sql.NullTime  `json:"sent_at"`
	SentCount   sql.NullInt64 `json:"sent_count"`
	FailedCount sql.NullInt64 `json:"failed_count"`
	BroadcastID int64         `json:"broadcast_id"`
}

func (q *Queries) UpdateBroadcastStatus(ctx context.Context, arg UpdateBroadcastStatusParams) (Broadcast, error) {
	row := q.db.QueryRowContext(ctx, updateBroadcastStatus,
		arg.Status,
		arg.SentAt,
		arg.SentCount,
		arg.FailedCount,
		arg.BroadcastID,
	)
	var i Broadcast
	err := row.Scan(
		&i.BroadcastID,
		&i.Message,
		&i.Audience,
		&i.SenderUserID,
		&i.PushEnabled,
		&i.ScheduledAt,
		&i.SentAt,
		&i.Status,
		&i.RecipientCount,
		&i.SentCount,
		&i.FailedCount,
		&i.CreatedAt,
	)
	return i, err
}
